<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metodologia BEM</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="container">
        <main>
            <h1 id="main">Metodologia BEM</h1>
        </main>
        <div class="parrafo">
            <section>
                <h3 >
                    
                    <p>DESCRIPCION</p> <br> La Metodología BEM (Block, Element, Modifier) es un enfoque de nomenclatura de clases en CSS que ayuda a estructurar y organizar el código de manera más clara y mantenible. <br><br>
                    <nav>
                        <a href="#Combinadores" class="bio-link">Combinadores  </a>
                        <a href="#Combinadores Lógicos" class="bio-link">Combinadores Lógicos  </a>
                        <a href="#Pseudoclases" class="bio-link">Pseudoclases</a>
                        <a href="#Pseudoclases de estructura" class="bio-link">Pseudoclases de estructura  </a>
                        <a href="#Reglas" class="bio-link">Reglass  </a>
                    </nav>
                    <br><br> <p>EJEMPLOS</p> <br>
                </h3>
            </section>
        </div>
        <div class="container2">
            <div class="ejemplo"> 
                <section>
                    
                        <li>
                            1. <p> (Block): </p><br>
                            <p>Definición:</p> Un bloque es un componente independiente y autónomo que tiene un significado propio. Es una entidad visual o de interfaz de usuario que se puede reutilizar.
                                <br><p>Convención de nomenclatura:</p>Utiliza un nombre descriptivo en minúsculas, sin espacios ni caracteres especiales. Para separar palabras, usa guiones (-). <p>Ejemplo</p> <br> div class="boton">...
                        </li>
                       
                </section>
            </div>
            <div class="ejemplo">
                <section>
                    <li>
                        2. <p>Elemento (Element): </p> <br>

                        <p>Definición:</p> Un elemento es una parte de un bloque que no tiene significado propio y que no se puede reutilizar independientemente del bloque al que pertenece.
                        <br><p>Convención de nomenclatura:</p> El nombre del elemento se construye añadiendo un doble guion bajo (__) al bloque, seguido por el nombre del elemento. <p>Ejemplo</p> <br> 
                        <br>div class="boton"<br>
                          span class="boton__icono">...span <br>
                          span class="boton__texto">Hacer clic span <br>
                        div 
                    </li>
                </section>
            </div>
        </div>

    </div>    
    <div class="container">
        <div class="ejemplo2">
            <section>
                3. <p> (Modifier): </p> <br>

                    <p>Definición:</p> Un modificador es una variación o estado de un bloque o elemento. Se utiliza para cambiar la apariencia o comportamiento del bloque o elemento sin modificar su estructura principal.
                    <br><p>Convención de nomenclatura:</p> El nombre del modificador se construye añadiendo un doble guion (-) al bloque o elemento, seguido por el nombre del modificador. <p>Ejemplo</p> <br>
                    div class="boton boton--primario">... div
            </section>
            <br><br>
            <section>
                <strong id="opacidad">Esta metodología facilita la identificación y el mantenimiento de estilos, especialmente en proyectos grandes, al proporcionar una estructura clara y jerárquica para las clases de CSS. </strong><br> <br>
            </section>
        </div>
    </div>
    <div class="container">
        <main>
            <h1 id="Combinadores">Combinadores</h1>
        </main>
    </div>
    <div class="container">
        <div class="parrafo">
            <section>
                <h3>
                    <p >DESCRIPCION</p><br> Un combinador CSS es un símbolo que permite unir dos o más selectores CSS para crear uno más complejo y potente. CSS ofrece varios tipos de combinadores, que se detallan en la siguiente tabla: <br>
                    <nav>
                        <a href="#Combiancion descendiente" class="bio-link">Descendiente  </a>
                        <a href="#Combinador hijo" class="bio-link">Hijo  </a>
                        <a href="#Combinador hermano adyacente" class="bio-link">Hermano adyacente  </a>
                        <a href="#Combinador hermano general" class="bio-link">Hermano general  </a>
                        <a href="#Combinador universal" class="bio-link">Universal  </a>
                        <a href="#main" class="bio-link">Volver</a>
                    </nav>
             </h3>
            </section>
        </div>
    </div>
    <div class="container">
        <div>
            <table>
               
                <tbody>
                    <tr>
                        <th>Nombre</th>
                        <th>Simbolo</th>
                        <th>Ejemplo</th>
                        <th>Significado</th>
                    </tr>
                    <tr>
                        <td>Combinacion descendiente</td>
                        <td>(espacio)</td>
                        <td>#page div { }</td>
                        <td>Selecciona elementos dentro de otros (cualquier nivel).</td>
                    </tr>
                    <tr>
                        <td>Combinador hijo</td>
                        <td>></td>
                        <td>#page > div { }</td>
                        <td>Selecciona elementos hijos directos (primer nivel).</td>
                    </tr>
                    <tr>
                        <td>Combinador hermano adyacente</td>
                        <td>+</td>
                        <td>div + div { }</td>
                        <td>Selecciona elementos contiguos a otros (mismo nivel)</td>
                    </tr>
                    <tr>
                        <td>Combinador hermano general</td>
                        <td>~</td>
                        <td>div ~ div { }</td>
                        <td>Selecciona elementos que siguen a otros (mismo nivel).</td>
                    </tr>
                    <tr>
                        <td>Combinador universal</td>
                        <td>*</td>
                        <td>#page * { }</td>
                        <td>Selecciona todos los elementos (cualquier nivel).</td>
                        
                    </tr>
                </tbody>
            </table>
            <br>
            <br>
            <div class="container">
                <section class="ejemplo2">
                    <p id="Combinacion descendiente">
                        Combinacion descendiente <br>
                    </p>
                    <br>
                    En CSS, se utiliza el término selector descendiente para referirse a una forma de seleccionar elementos específicos que están contenidos dentro de otros elementos. Aunque esta técnica puede parecer simple, es crucial ejercer precaución, ya que puede convertirse en una fuente de problemas si no se comprende adecuadamente.
                    <img class="imagenes" src="imagenes/Combinador descendiente.png" alt="">
                    <br>
                    <p>Repasemos varios detalles importantes respecto a este combinador CSS:</p>
                    <br>
                    <li>Se están seleccionando todos los elementos div que están dentro del elemento con id="page".</li>
                    <li>Observa que se seleccionan independientemente del nivel al que estén (hijos, nietos, ...)</li>
                    <li>En este caso, el div de div#page es innecesario, ya que habíamos dicho que los id no se pueden repetir. Si ya existe un elemento con id page, no hace falta diferenciarlo también por etiqueta. Si se tratase de una clase, sí podría usarse.</li><br>
                    Es posible crear selectores altamente complejos con tantos elementos como se desee, pero una recomendación es siempre procurar mantenerlos lo más simples posible. Cuantos más elementos descendientes se incluyan en un selector, mayor será la complejidad en el procesamiento de esa regla por parte de los navegadores, y mayor será la especificidad del selector, lo que podría introducir ciertas complicaciones.
                </section>
                <section class="ejemplo2">
                    <br>
                    <p id="Combinador hijo">
                        Combinador hijo <br>
                    </p>
                    <br>
                    También es factible hacer referencia a elementos hermanos, que son aquellos elementos que están directamente adyacentes al elemento especificado. Utilizando el símbolo + en el selector de hermano adyacente, es posible seleccionar elementos hermanos que están uno junto al otro en el mismo nivel:
                    <img class="imagenes" src="imagenes/Combinador hermano contiguo.png" alt="">
                    <br>
                    Al contrario que en el caso anterior, no se seleccionan todos los elementos div descendientes, sino solo aquellos que son hijos directos del primer elemento especificado.
                </section>
                <section class="ejemplo2">
                    <br>
                    <p id="Combinador hermano adyacente">
                        Combinador hermano adyacente <br>
                    </p>
                    <br>
                    Aunque el selector descendiente es bastante interesante, nos puede interesar hacer la misma operación, pero en lugar de seleccionar todos los elementos descendientes, seleccionar solo los descendientes directos del elemento con el símbolo >, descartando así nietos y sucesivos.
                    <img class="imagenes" src="imagenes/combinador hijo.png" alt="">
                    <br>
                    Obsérvese que el primer elemento span no es seleccionado, puesto que es el que estamos tomando de referencia de base. Una buena forma para entenderlo es leerlo de la siguiente forma: «todo elemento span que esté inmediatamente precedido de un span».
                </section>
                <section class="ejemplo2">
                    <br>
                    <p id=" Combinador hermano general">
                        Combinador hermano general <br>
                    </p>
                    <br>
                    Si consideramos otras posibilidades en el ejemplo anterior, es posible que necesitemos ser menos específicos. En lugar de seleccionar solo los elementos hermanos que son adyacentes, podríamos querer seleccionar todos los hermanos en general, sin requerir que sean adyacentes. Esto se logra utilizando el "selector hermano general, que se representa con el símbolo ~:
                    <img class="imagenes" src="imagenes/Combinador hermano general.png" alt="">
                    <br>                    
                    Como se ve en el ejemplo, no es necesario que el elemento strong se encuentre adyacente al primero, sino que basta con que esté a continuación y sean hermanos en el mismo nivel.
                </section>
                <section class="ejemplo2">
                    <br>
                    <p id="Combinador universal">
                        Combinador universal <br>
                    </p>
                    <br>
                    Por último, el selector universal se simboliza con un asterisco * y es la forma de aplicar ciertos estilos en TODOS Y CADA UNO de los elementos HTML correspondientes.
                    <img class="imagenes" src="imagenes/Combinador universal.png" alt="">
                    <br>
                    Este ejemplo selecciona todos los elementos dentro de div#menu. Es importante recalcar la diferencia de seleccionar #menu, a seleccionar todos los elementos dentro de #menu, que es lo que estamos haciendo en este caso.
                </section>
            </div>
        </div>
        <br><br><br>
    </div>
    <div class="container">
        <main>
            <h1 id="Combinadores Lógicos">Combinadores Lógicos</h1> <br>
        </main>
        <nav class="links">
            <a href="#tabla" class="bio-link">Tabla</a>
            <a href="#combinador is" class="bio-link">Combinador :is</a>
            <a href="#combinador where" class="bio-link">Combinador :where</a>
            <a href="#combinador has" class="bio-link">Combinador :has</a>
            <a href="#combinador not" class="bio-link">Combinador :not</a>
            <a href="#main" class="bio-link">Volver</a>
        </nav>
        <div class="parrafo">
            <section>
                <p>DESCRIPCION</p><br>En algunas ocasiones, puede ser deseable agrupar varios selectores con el fin de reducir la cantidad de código o reutilizar bloques de CSS en diversas situaciones, lo que hace que los estilos sean más versátiles y eficientes.
                La forma más sencilla de conseguir esto, es crear agrupaciones con diferentes selectores separando por <br>
            </section>
            <br>
        </div>
        <h2><p>AGRUPACION DE SELECTORES</p></h2>
        <div class="parrafo">
            <section>
                Imagina una situación en la que varios bloques de código CSS contienen las mismas propiedades con los mismos valores. Generalmente, escribir cada bloque de forma individual no es apropiado, ya que duplica un código que es exactamente igual: <br>
                <br>
                <img class="imagenes" src="imagenes/repetir etiquetas css.png" alt="">
            </section>
            <br>
        </div>
        <div class="container2">
            <div class="ejemplo"> 
                <section>
                    <li>
                        Si esto ocurre a menudo, el tamaño del documento CSS será más grande y tardará más en descargarse. Una buena práctica para evitarlo es ahorrar texto y simplificar nuestro documento CSS lo máximo posible, por lo que podemos hacer uso de la agrupación CSS utilizando el símbolo de la coma.
                    </li>
                    <br><br>
                    <img class="imagenes_pequeñas" src="imagenes/solucion repetir css.png" alt="">       
                </section>
            </div>
            <div class="ejemplo">
                <section>
                    <li>
                        Simplifica por responsabilidades: .container-alert y .container-warning parecen tener un concepto muy similar: alertas o mensajes de advertencia. Es posible que estos selectores tengan la misma funcionalidad y sean sinónimos. <br>
                         Si es así, lo ideal sería refactorizar y simplificarlos a uno: .container-warning, haciendo desaparecer el otro.
                        
                    </li>
                    <li>
                        Legibilidad por delante: El código CSS por si sólo puede ser difícil de leer y mantener. Aunque a priori puede parecer que es mejor escribir la lista de selectores uno detrás de otro, la experiencia nos dicta que deberíamos separarlos en una línea diferente cada selector. Esto lo hace mucho más legible a la hora de leer.
                        <img class="imagenes_pequeñas" src="imagenes/otra solucion css.png" alt="">
                    </li>
                </section>
            </div>
        </div>
        <div class="container">
            <div class="ejemplo2">            
                <section>
                    <strong id="opacidad">Estos consejos pueden parecer poco importantes, pero a medida que avanzamos con nuestro diseño y escribimos más código CSS, este se hace muy grande y difícil de mantener, por lo que cuanto más sencillo lo mantengamos, mejor. </strong><br> <br>
                </section>
            </div>
        </div>
        <div class="container">
            <div class="ejemplo2">
                <section id="tabla">
                    Sin embargo, las comas sólo son la forma más sencilla y simple de reutilizar selectores. En CSS, tenemos a nuestra disposición una serie de mecanismos para agrupar o combinar selectores de una forma más potente y flexible, dentro de una categoría denominada combinadores lógicos.
                    Estos combinadores lógicos nos permiten seleccionar elementos con ciertas restricciones y funcionan como una pseudoclase (ver más adelante), solo que se le pueden pasar parámetros, ya que son de tipo pseudoclase funcional.
                </section>
            </div>
        </div>
        <div class="container">
            <br>
            <br>
            <div>
                <table>
                    <tbody>
                        <tr>
                            <th>Selector</th>
                            <th>Descripcion</th>
                        </tr>
                        <tr>
                            <td>:is()</td>
                            <td>Agrupaciones. Idem al anterior, pero permite combinar con otros selectores.</td>

                        </tr>
                        <tr>
                            <td>where()</td>
                            <td>Agrupaciones. Idem al anterior, pero con menor especificidad CSS.</td>

                        </tr>
                        <tr>
                            <td>:has()</td>
                            <td>Permite seleccionar elementos padre que tengan ciertas características en sus hijos.</td>

                        </tr>
                        <tr>
                            <td>:not()</td>
                            <td>Permite seleccionar elementos que no cumplan ciertas características.</td>

                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div class="container">
            <br><br>
            <main>
                <h1 id="combinador is"><p>El combinador :is()</p></h1> <br>
            </main>
            <nav>
                <a href="#Combinadores Lógicos" class="bio-link">Volver</a>
            </nav>
            <br>
            <div class="ejemplo2">
                <section>
                    La pseudoclase funcional :is() es un reemplazo práctico de la agrupación de selectores mediante comas, que permite reescribir selectores complejos de una forma mucho más práctica y compacta, ya que permite combinar y acumular con otros selectores anteriores o posteriores a :is(). <br> <br>
                    <img src="imagenes/is.png" class="imagenes_pequeñas"> <br><br>
                    Esto nos permite crear un código mucho más compacto y sencillo de leer y escribir. Antiguamente, esta pseudoclase era conocida como :matches(), pero finalmente fue renombrada a :is(), por lo que es posible que nos la encontremos de esta forma si accedemos a documentación antigua.
                </section>
            </div>
            <br><br>
            <main>
                <h1 id="combinador where"><p>El combinador :where()</p></h1> <br>
            </main>
            <nav>
                <a href="#Combinadores Lógicos" class="bio-link">Volver</a>
            </nav>
            <br>
            <div class="ejemplo2">
                <section>
                    El combinador :where() funciona exactamente igual que el combinador :is(), la única diferencia que tiene es en cuanto a la especificidad CSS. Mientras que con :is(), la especificidad es el valor más alto de la lista de parámetros, en el caso de :where() es siempre cero. <br> <br>
                    <img src="imagenes/where.png" class="imagenes_pequeñas"> <br>
                    Este combinador :where() puede ser útil para casos en los que se quiere anular la especificidad de un elemento fácilemente si se sobreescribe con otro selector.
                </section>
            </div>
            <br><br>
            <main>
                <h1 id="combinador has"><p>El combinador :has()</p></h1> <br>
            </main>
            <nav>
                <a href="#Combinadores Lógicos" class="bio-link">Volver</a>
            </nav>
            <br>
            <div class="ejemplo2">
                <section>
                    La pseudoclase :has() permite seleccionar el elemento precedido, si sus elementos hijos cumplen los criterios indicados por parámetro. Esto puede resultar un poco confuso, pero se ve claramente en el siguiente ejemplo: <br> <br>
                    <img src="imagenes/has.png" class="imagenes_pequeñas"> <br>
                    En este caso, la propiedad text-decoration: none se aplica sobre el enlace /a/, sólo si en el interior del enlace existe una etiqueta /img/. Este ejemplo podría ser muy útil para eliminar estilos sobre imágenes que son enlaces. <br>
                    Algunos detalles interesantes sobre la pseudoclase funcional :has(): <br>
                    <li >
                        La pseudoclase :has() no se puede anidar dentro de otra :has().
                    </li>
                    <li>
                        Los pseudoelementos como ::before o ::after no funcionan dentro de :has().
                    </li>
                    <li>    
                        La especificidad de :has() es el valor más alto de los selectores indicados por parámetro.
                    </li>
                </section>
            </div>
            <br><br>
            <main>
                <h1 id="combinador not"><p>El combinador :not()</p></h1> <br>
            </main>
            <nav>
                <a href="#Combinadores Lógicos" class="bio-link">Volver</a>
            </nav>
            <br>
            <div class="ejemplo2">
                <section>
                    La pseudoclase de negación :not() es muy útil, ya que permite seleccionar todos los elementos que no cumplan los criterios indicados en sus parámetros entre paréntesis.Veamos un sencillo ejemplo: <br> <br>
                    <img src="imagenes/not.png" class="imagenes_pequeñas">
                    Este pequeño fragmento de código nos indica que todos los párrafos /p/ que no pertenezcan a la clase .general, se les aplique el estilo especificado. <br>
                    Algunos detalles adicionales sobre la pseudoclase funcional :not(): <br>
                    <li >
                        Se puede indicar una lista de criterios por parámetro, y no uno solo (como en el ejemplo anterior).
                    </li>
                    <li>
                        La pseudoclase :not() no acepta pseudoelementos como ::before o ::after por parámetro.
                    </li>
                    <li>    
                        Al igual que con :is(), la especificidad de :not() es el valor más alto de sus parámetros.
                    </li>
                </section>
            </div>
            <br><br>
            <main>
                <h1 id="Pseudoclases">Pseudoclases</h1>
            </main>
            <div class="parrafo">
                <section>
                    <h3 >
                        <p>DESCRIPCION</p> <br> Las pseudoclases se utilizan para hacer referencia a elementos HTML que tengan un cierto comportamiento concreto. Volvamos a recordar el esquema general de sintaxis de CSS, donde ahora añadiremos las pseudoclases, que se definen añadiendo dos puntos antes del nombre de la pseudoclase concreta <br><br>
                    </h3>    
                    <nav>
                        <a href="#main" class="bio-link">Volver</a>
                    </nav>
                </section>
            </div>
            <main>
                <h2>Tipos de Pseudoclases</h2>
            </main>
            <div class="container">
                <div>
                    <table>
                        <tbody>
                            <tr>
                                <th>Pseudoclase</th>
                                <th>Más información</th>
                            </tr>
                            <tr>
                                <td>Interacción</td>
                                <td>Pseudoclases relacionadas con acciones de usuario. Ver más adelante en esta página.</td>
    
                            </tr>
                            <tr>
                                <td>Ubicación</td>
                                <td>Pseudoclases relacionadas con enlaces o ubicaciones. Ver más adelante en esta página</td>
    
                            </tr>
                            <tr>
                                <td>Idioma</td>
                                <td>Pseudoclases relacionadas con idiomas. Ver más adelante en esta página.</td>
    
                            </tr>
                            <tr>
                                <td>Estructura</td>
                                <td><a href="https://lenguajecss.com/css/pseudoclases/estructura/" class="links">Ver pseudoclases de estructura de documentos HTML</a></td>
    
                            </tr>
                            <tr>
                                <td>Formulario</td>
                                <td><a href="https://lenguajecss.com/css/pseudoclases/formularios/" class="links">Ver pseudoclases de formulario HTML</a></td>
    
                            </tr>
                            <tr>
                                <td>Estado</td>
                                <td>Pseudoclases relacionadas con el estado de modales o similares. Ver más adelante en esta página.</td>
    
                            </tr>
                            <tr>
                                <td>Paginado</td>
                                <td><a href="https://lenguajecss.com/css/responsive-web-design/medios-paginados/#pseudoclases-de-p%C3%A1gina" class="links">Ver pseudoclases de paginado de documentos HTML</a></td>
    
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
</body>
</html>